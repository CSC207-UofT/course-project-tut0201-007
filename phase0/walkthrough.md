First, the user runs the class **controllers.CommandLineInterface**, which then queries the user for the number of courses they want to take. After that, the **controllers.CommandLineInterface** queries the user for entities.Course Codes of courses they want to take, stores them, and calls one of our Use Cases, **workers.Scheduler**, which creates a **entities.Schedule**. Internally, the **workers.Scheduler** uses another Use Case, **workers.CourseCreator**, which instantiates a **entities.Course** object using the information retrieved by **workers.APIWorker**. **workers.APIWorker** queries the U of T Timetable API by course code, and retrieves course info in JSON format.

The **workers.Scheduler** calls **workers.CourseCreator** for every course code input. Each time, it also outputs the created **entities.Course** to the CLI. When **workers.Scheduler** finishes, the **controllers.CommandLineInterface** prints the string representation of the generated **entities.Schedule**.

## Example

Let's assume for the sake of example that the user wants to take 2 courses, which are CSC258 and MAT237. They will input that through **controllers.CommandLineInterface**, which will parse the number of courses as well as the entities.Course Codes. It will use **workers.Scheduler** to generate a schedule for CSC258 & MAT237. In the process, it will use **workers.CourseCreator** twice, for both MAT237 & CSC258. Each **workers.CourseCreator** will use the **workers.APIWorker** to get info on MAT237 & CSC258, respectively. As each **entities.Course** is created, their string representations will be output. That means the Lecture & Tutorial sections of MAT237 & CSC258 will be output. Finally, when **workers.Scheduler** finishes, the string representation of a **entities.Schedule** of MAT237 & CSC258 will be output. This means printing the lecture and tutorial **Sessions** that are in the schedule. 